// Link the provider and client, 
// load the db URL from the environment 
// variables using 'env()'

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Patient Table/Relation Creation
model Patient {
  id          String   @id @default(uuid())
  patientId   String   @unique
  email       String   @unique
  phone       String   @default("+1234567890") 
  name        String
  age         Int
  dateOfBirth DateTime
  term        Int
  dueDate     DateTime

  patientAssignments PatientAssignment[]
  readings           Reading[]
  notifications      Notification[]
}

// Doctor Table/Relation Creation
model Doctor {
  // Table attributes and basic constraints:
  id        String  @id @default(uuid()) // PK + unique user id
  email     String  @unique
  phone     String  @default("+1234567890")
  name      String
  specialty String? // Nullable

  // Each healthcare provider can have a list of assignments to oversee the patients
  patientAssignments PatientAssignment[]
  notifications      Notification[]
}

// PatientAssignment Table/Relation Creation
// tracks the assignment of patients to doctors
model PatientAssignment {
  id            String   @id @default(uuid())
  doctorId      String
  patientId     String
  lastVisitDate DateTime
  addedDate     DateTime

  hasMessageForDoctor  Boolean @default(false)
  hasMessageForPatient Boolean @default(false)

  doctor          Doctor          @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient         Patient         @relation(fields: [patientId], references: [id], onDelete: Cascade)
  messages        Message[]
  recommendations Recommendation[]
}


model Recommendation {
  id                  String   @id @default(uuid())
  patientAssignmentId String
  title               String
  description         String
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  isActive            Boolean  @default(true)

  // Relationship
  patientAssignment PatientAssignment @relation(fields: [patientAssignmentId], references: [id], onDelete: Cascade)

  @@index([patientAssignmentId])
}

// Reading Table/Relation Creation
model Reading {
  id        String      @id @default(uuid()) // PK + unique user id
  patientId String
  date      DateTime // date of the when the reading was taken
  time      String // time of when the reading was taken
  // this type is defined at the bottom of the file, 
  // enumarted the timings of the reading
  type      ReadingType
  level     Float
  status    ReadingStatus @default(NORMAL)
  // Nullable attribute, patient may not have record notes on the reading
  notes     String?

  // Relationships and forgein keys:
  // patient who recorded the reading, mapped to patientID
  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
}

model Message {
  id                  String     @id @default(uuid())
  patientAssignmentId String // Links to PatientAssignment
  senderId            String // Either doctorId or patientId
  senderType          SenderType // DOCTOR or PATIENT
  content             String
  timestamp           DateTime   @default(now())
  isRead              Boolean    @default(false)

  // Relationship
  patientAssignment PatientAssignment @relation(fields: [patientAssignmentId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  content   String
  metadata  Json? //  Store reading values, message previews, etc. as JSON
  isRead    Boolean          @default(false)
  isArchived Boolean         @default(false)
  createdAt DateTime         @default(now())
  readAt    DateTime?

  //  Only recipient relationships
  patientId String?
  doctorId  String?

  patient Patient? @relation(fields: [patientId], references: [id])
  doctor  Doctor?  @relation(fields: [doctorId], references: [id])

  @@index([patientId, isRead, isArchived])
  @@index([doctorId, isRead, isArchived])
  @@index([createdAt])
  @@map("notifications")
}


enum NotificationType {
  DANGEROUS_READING    // For glucose readings that are HIGH or ELEVATED
  NEW_MESSAGE         // For new messages between doctor and patient
  NEW_RECOMMENDATION  // For new recommendations from doctor to patient
  DAILY_REMINDER      // For daily glucose reading reminders
}

// enumarating messaging sender type
enum SenderType {
  DOCTOR
  PATIENT
}

// enumarting the 6 types of the readings we could have
enum ReadingType {
  BEFORE_BREAKFAST
  AFTER_BREAKFAST
  BEFORE_LUNCH
  AFTER_LUNCH
  BEFORE_DINNER
  AFTER_DINNER
}

// enumarting status of patient glucose readings
enum ReadingStatus {
  NORMAL
  HIGH
  ELEVATED
}
